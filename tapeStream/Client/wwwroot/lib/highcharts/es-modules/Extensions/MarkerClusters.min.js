"use strict";import A from"../Core/Animation/AnimationUtilities.js";var animObject=A.animObject;import BaseSeries from"../Core/Series/Series.js";import Chart from"../Core/Chart/Chart.js";import H from"../Core/Globals.js";import O from"../Core/Options.js";var defaultOptions=O.defaultOptions;import Point from"../Core/Series/Point.js";import SVGRenderer from"../Core/Renderer/SVG/SVGRenderer.js";import U from"../Core/Utilities.js";var addEvent=U.addEvent,defined=U.defined,error=U.error,isArray=U.isArray,isFunction=U.isFunction,isObject=U.isObject,isNumber=U.isNumber,merge=U.merge,objectEach=U.objectEach,relativeLength=U.relativeLength,syncTimeout=U.syncTimeout;import Axis from"../Core/Axis/Axis.js";import"../Series/LineSeries.js";var Series=H.Series,Scatter=BaseSeries.seriesTypes.scatter,baseGeneratePoints=Series.prototype.generatePoints,stateIdCounter=0,oldPointsStateId=[],clusterDefaultOptions={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}};function getClusterPosition(t){var e,i=t.length,a=0,r=0;for(e=0;e<i;e++)a+=t[e].x,r+=t[e].y;return{x:a/i,y:r/i}}function getDataState(t,e){var i=[];return i.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){i[t.dataIndex]=t})}),t.noise.forEach(function(t){i[t.data[0].dataIndex]=t.data[0]}),i}function fadeInElement(t,e,i){t.attr({opacity:e}).animate({opacity:1},i)}function fadeInStatePoint(t,e,i,a,r){t.point&&(a&&t.point.graphic&&(t.point.graphic.show(),fadeInElement(t.point.graphic,e,i)),r&&t.point.dataLabel&&(t.point.dataLabel.show(),fadeInElement(t.point.dataLabel,e,i)))}function hideStatePoint(t,e,i){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),i&&t.point.dataLabel&&t.point.dataLabel.hide())}function destroyOldPoints(t){t&&objectEach(t,function(t){t.point&&t.point.destroy&&t.point.destroy()})}function fadeInNewPointAndDestoryOld(t,e,i,a){fadeInStatePoint(t,a,i,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}function getStateId(){return Math.random().toString(36).substring(2,7)+"-"+stateIdCounter++}(defaultOptions.plotOptions||{}).series=merge((defaultOptions.plotOptions||{}).series,{cluster:clusterDefaultOptions,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}),SVGRenderer.prototype.symbols.cluster=function(t,e,i,a){var r,o,s=i/2,n=a/2;return r=this.arc(t+s,e+n,s-4,n-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),o=this.arc(t+s,e+n,s-3,n-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:s-2,open:!1}),this.arc(t+s,e+n,s-1,n-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:s,open:!1}).concat(o,r)},Scatter.prototype.animateClusterPoint=function(t){var e,i,a,r=this.xAxis,o=this.yAxis,s=this.chart,n=this.options.cluster,l=animObject((n||{}).animation),d=l.duration||500,p=(this.markerClusterInfo||{}).pointsState,u=(p||{}).newState,h=(p||{}).oldState,c=[],f=0,m=0,g=0,x=!1,y=!1;h&&u&&(a=u[t.stateId],m=r.toPixels(a.x)-s.plotLeft,g=o.toPixels(a.y)-s.plotTop,1===a.parentsId.length?(e=(u||{})[t.stateId].parentsId[0],i=h[e],a.point&&a.point.graphic&&i&&i.point&&i.point.plotX&&i.point.plotY&&i.point.plotX!==a.point.plotX&&i.point.plotY!==a.point.plotY&&(f=a.point.graphic.getBBox().width/2,a.point.graphic.attr({x:i.point.plotX-f,y:i.point.plotY-f}),a.point.graphic.animate({x:m-(a.point.graphic.radius||0),y:g-(a.point.graphic.radius||0)},l,function(){y=!0,i.point&&i.point.destroy&&i.point.destroy()}),a.point.dataLabel&&a.point.dataLabel.alignAttr&&i.point.dataLabel&&i.point.dataLabel.alignAttr&&(a.point.dataLabel.attr({x:i.point.dataLabel.alignAttr.x,y:i.point.dataLabel.alignAttr.y}),a.point.dataLabel.animate({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y},l)))):0===a.parentsId.length?(hideStatePoint(a,!0,!0),syncTimeout(function(){fadeInStatePoint(a,.1,l,!0,!0)},d/2)):(hideStatePoint(a,!0,!0),a.parentsId.forEach(function(t){h&&h[t]&&(i=h[t],c.push(i),i.point&&i.point.graphic&&(x=!0,i.point.graphic.show(),i.point.graphic.animate({x:m-(i.point.graphic.radius||0),y:g-(i.point.graphic.radius||0),opacity:.4},l,function(){y=!0,fadeInNewPointAndDestoryOld(a,c,l,.7)}),i.point.dataLabel&&-9999!==i.point.dataLabel.y&&a.point&&a.point.dataLabel&&a.point.dataLabel.alignAttr&&(i.point.dataLabel.show(),i.point.dataLabel.animate({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y,opacity:.4},l))))}),syncTimeout(function(){y||fadeInNewPointAndDestoryOld(a,c,l,.85)},d),x||syncTimeout(function(){fadeInNewPointAndDestoryOld(a,c,l,.1)},d/2)))},Scatter.prototype.getGridOffset=function(){var t=this.chart,e=this.xAxis,i=this.yAxis;return{plotLeft:this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:this.dataMinY&&this.dataMaxY?i.reversed?i.toPixels(this.dataMinY):i.toPixels(this.dataMaxY):t.plotTop}},Scatter.prototype.getScaledGridSize=function(t){var e,i,a=this.xAxis,r=!0,o=1,s=1,n=t.processedGridSize||clusterDefaultOptions.layoutAlgorithm.gridSize;for(this.gridValueSize||(this.gridValueSize=Math.abs(a.toValue(n)-a.toValue(0))),e=+(n/(a.toPixels(this.gridValueSize)-a.toPixels(0))).toFixed(14);r&&1!==e;)i=Math.pow(2,o),e>.75&&e<1.25?r=!1:e>=1/i&&e<1/i*2?(r=!1,s=i):e<=i&&e>i/2&&(r=!1,s=1/i),o++;return n/s/e},Scatter.prototype.getRealExtremes=function(){var t,e,i=this.chart,a=this.xAxis,r=this.yAxis,o=a?a.toValue(i.plotLeft):0,s=a?a.toValue(i.plotLeft+i.plotWidth):0,n=r?r.toValue(i.plotTop):0,l=r?r.toValue(i.plotTop+i.plotHeight):0;return o>s&&(s=(t=[o,s])[0],o=t[1]),n>l&&(l=(e=[n,l])[0],n=e[1]),{minX:o,maxX:s,minY:n,maxY:l}},Scatter.prototype.onDrillToCluster=function(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){var e,i,a,r,o,s,n,l,d,p,u=t.point||t.target,h=u.series,c=u.series.xAxis,f=u.series.yAxis,m=u.series.chart;(h.options.cluster||{}).drillToCluster&&u.clusteredData&&(o=u.clusteredData.map(function(t){return t.x}).sort(function(t,e){return t-e}),s=u.clusteredData.map(function(t){return t.y}).sort(function(t,e){return t-e}),n=o[0],d=o[o.length-1],l=s[0],p=s[s.length-1],a=Math.abs(.1*(d-n)),r=Math.abs(.1*(p-l)),m.pointer.zoomX=!0,m.pointer.zoomY=!0,n>d&&(n=(e=[d,n])[0],d=e[1]),l>p&&(l=(i=[p,l])[0],p=i[1]),m.zoom({originalEvent:t,xAxis:[{axis:c,min:n-a,max:d+a}],yAxis:[{axis:f,min:l-r,max:p+r}]}))})},Scatter.prototype.getClusterDistancesFromPoint=function(t,e,i){var a,r,o=this.xAxis,s=this.yAxis,n=[];for(a=0;a<t.length;a++)r=Math.sqrt(Math.pow(o.toPixels(e)-o.toPixels(t[a].posX),2)+Math.pow(s.toPixels(i)-s.toPixels(t[a].posY),2)),n.push({clusterIndex:a,distance:r});return n.sort(function(t,e){return t.distance-e.distance})},Scatter.prototype.getPointsState=function(t,e,i){var a,r,o,s=e?getDataState(e,i):[],n=getDataState(t,i),l={};for(oldPointsStateId=[],t.clusters.forEach(function(t){l[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){l[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),o=0;o<n.length;o++)a=n[o],r=s[o],a&&r&&a.parentStateId&&r.parentStateId&&l[a.parentStateId]&&-1===l[a.parentStateId].parentsId.indexOf(r.parentStateId)&&(l[a.parentStateId].parentsId.push(r.parentStateId),-1===oldPointsStateId.indexOf(r.parentStateId)&&oldPointsStateId.push(r.parentStateId));return l},Scatter.prototype.markerClusterAlgorithms={grid:function(t,e,i,a){var r,o,s,n,l,d,p=this.xAxis,u=this.yAxis,h={},c=this.getGridOffset();for(r=this.getScaledGridSize(a),d=0;d<t.length;d++)o=p.toPixels(t[d])-c.plotLeft,s=u.toPixels(e[d])-c.plotTop,n=Math.floor(o/r),h[l=Math.floor(s/r)+"-"+n]||(h[l]=[]),h[l].push({dataIndex:i[d],x:t[d],y:e[d]});return h},kmeans:function(t,e,i,a){var r,o,s,n,l,d=[],p=[],u={},h=a.processedDistance||clusterDefaultOptions.layoutAlgorithm.distance,c=a.iterations,f=0,m=!0,g=0,x=0,y=[];for(s in a.processedGridSize=a.processedDistance,o=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,i,a):{})o[s].length>1&&(r=getClusterPosition(o[s]),d.push({posX:r.x,posY:r.y,oldX:0,oldY:0,startPointsLen:o[s].length,points:[]}));for(;m;){for(d.map(function(t){return t.points.length=0,t}),p.length=0,n=0;n<t.length;n++)g=t[n],x=e[n],(y=this.getClusterDistancesFromPoint(d,g,x)).length&&y[0].distance<h?d[y[0].clusterIndex].points.push({x:g,y:x,dataIndex:i[n]}):p.push({x:g,y:x,dataIndex:i[n]});for(l=0;l<d.length;l++)1===d[l].points.length&&(y=this.getClusterDistancesFromPoint(d,d[l].points[0].x,d[l].points[0].y))[1].distance<h&&(d[y[1].clusterIndex].points.push(d[l].points[0]),d[y[0].clusterIndex].points.length=0);for(m=!1,l=0;l<d.length;l++)r=getClusterPosition(d[l].points),d[l].oldX=d[l].posX,d[l].oldY=d[l].posY,d[l].posX=r.x,d[l].posY=r.y,(d[l].posX>d[l].oldX+1||d[l].posX<d[l].oldX-1||d[l].posY>d[l].oldY+1||d[l].posY<d[l].oldY-1)&&(m=!0);c&&(m=f<c-1),f++}return d.forEach(function(t,e){u["cluster"+e]=t.points}),p.forEach(function(t,e){u["noise"+e]=[t]}),u},optimizedKmeans:function(t,e,i,a){var r,o,s=this.xAxis,n=this.yAxis,l=a.processedDistance||clusterDefaultOptions.layoutAlgorithm.gridSize,d={},p=this.getRealExtremes(),u=(this.options.cluster||{}).marker;return!this.markerClusterInfo||this.initMaxX&&this.initMaxX<p.maxX||this.initMinX&&this.initMinX>p.minX||this.initMaxY&&this.initMaxY<p.maxY||this.initMinY&&this.initMinY>p.minY?(this.initMaxX=p.maxX,this.initMinX=p.minX,this.initMaxY=p.maxY,this.initMinY=p.minY,d=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,i,a):{},this.baseClusters=null):(this.baseClusters||(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters.forEach(function(t){t.pointsOutside=[],t.pointsInside=[],t.data.forEach(function(e){r=Math.sqrt(Math.pow(s.toPixels(e.x)-s.toPixels(t.x),2)+Math.pow(n.toPixels(e.y)-n.toPixels(t.y),2)),o=t.clusterZone&&t.clusterZone.marker&&t.clusterZone.marker.radius?t.clusterZone.marker.radius:u&&u.radius?u.radius:clusterDefaultOptions.marker.radius,r>o+(l-o>=0?l-o:o)&&defined(t.pointsOutside)?t.pointsOutside.push(e):defined(t.pointsInside)&&t.pointsInside.push(e)}),t.pointsInside.length&&(d[t.id]=t.pointsInside),t.pointsOutside.forEach(function(e,i){d[t.id+"_noise"+i]=[e]})}),this.baseClusters.noise.forEach(function(t){d[t.id]=t.data})),d}},Scatter.prototype.preventClusterCollisions=function(t){var e,i,a,r,o,s,n,l,d,p,u,h,c,f,m,g=this.xAxis,x=this.yAxis,y=t.key.split("-").map(parseFloat),S=y[0],C=y[1],I=t.gridSize,b=t.groupedData,A=t.defaultRadius,P=t.clusterRadius,D=C*I,k=S*I,M=g.toPixels(t.x),v=x.toPixels(t.y),O=[],E=0,L=0,X=(this.options.cluster||{}).marker,Y=(this.options.cluster||{}).zones,z=this.getGridOffset();for(M-=z.plotLeft,v-=z.plotTop,n=1;n<5;n++)for(a=n%2?-1:1,r=n<3?-1:1,o=Math.floor((M+a*P)/I),c=[(s=Math.floor((v+r*P)/I))+"-"+o,s+"-"+C,S+"-"+o],l=0;l<c.length;l++)-1===O.indexOf(c[l])&&c[l]!==t.key&&O.push(c[l]);return O.forEach(function(t){var a;if(b[t]){if(b[t].posX||(u=getClusterPosition(b[t]),b[t].posX=u.x,b[t].posY=u.y),e=g.toPixels(b[t].posX||0)-z.plotLeft,i=x.toPixels(b[t].posY||0)-z.plotTop,a=t.split("-").map(parseFloat),p=a[0],d=a[1],Y)for(E=b[t].length,n=0;n<Y.length;n++)E>=Y[n].from&&E<=Y[n].to&&(L=defined((Y[n].marker||{}).radius)?Y[n].marker.radius||0:X&&X.radius?X.radius:clusterDefaultOptions.marker.radius);b[t].length>1&&0===L&&X&&X.radius?L=X.radius:1===b[t].length&&(L=A),h=P+L,L=0,d!==C&&Math.abs(M-e)<h&&(M=d-C<0?D+P:D+I-P),p!==S&&Math.abs(v-i)<h&&(v=p-S<0?k+P:k+I-P)}}),f=g.toValue(M+z.plotLeft),m=x.toValue(v+z.plotTop),b[t.key].posX=f,b[t.key].posY=m,{x:f,y:m}},Scatter.prototype.isValidGroupedDataObject=function(t){var e,i=!1;return!!isObject(t)&&(objectEach(t,function(t){if(i=!0,isArray(t)&&t.length){for(e=0;e<t.length;e++)if(!isObject(t[e])||!t[e].x||!t[e].y)return void(i=!1)}else i=!1}),i)},Scatter.prototype.getClusteredData=function(t,e){var i,a,r,o,s,n,l,d,p,u,h,c,f,m,g=[],x=[],y=[],S=[],C=[],I=0,b=Math.max(2,e.minimumClusterSize||2);if(isFunction(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return error("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(m in t)if(t[m].length>=b){if(r=t[m],i=getStateId(),s=r.length,e.zones)for(f=0;f<e.zones.length;f++)s>=e.zones[f].from&&s<=e.zones[f].to&&((h=e.zones[f]).zoneIndex=f,u=e.zones[f].marker,c=e.zones[f].className);for(p=getClusterPosition(r),"grid"!==e.layoutAlgorithm.type||e.allowOverlap?l={x:p.x,y:p.y}:(n=this.options.marker||{},l=this.preventClusterCollisions({x:p.x,y:p.y,key:m,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:n.radius||3+(n.lineWidth||0),clusterRadius:u&&u.radius?u.radius:(e.marker||{}).radius||clusterDefaultOptions.marker.radius})),f=0;f<s;f++)r[f].parentStateId=i;if(y.push({x:l.x,y:l.y,id:m,stateId:i,index:I,data:r,clusterZone:h,clusterZoneClassName:c}),g.push(l.x),x.push(l.y),C.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:merge(e.marker,{states:e.states},u||{})}}),this.options.data&&this.options.data.length)for(f=0;f<s;f++)isObject(this.options.data[r[f].dataIndex])&&(r[f].options=this.options.data[r[f].dataIndex]);I++,u=null}else for(f=0;f<t[m].length;f++)a=t[m][f],i=getStateId(),d=null,o=((this.options||{}).data||[])[a.dataIndex],g.push(a.x),x.push(a.y),a.parentStateId=i,S.push({x:a.x,y:a.y,id:m,stateId:i,index:I,data:t[m]}),d=o&&"object"==typeof o&&!isArray(o)?merge(o,{x:a.x,y:a.y}):{userOptions:o,x:a.x,y:a.y},C.push({options:d}),I++;return{clusters:y,noise:S,groupedXData:g,groupedYData:x,groupMap:C}},Scatter.prototype.destroyClusteredData=function(){(this.markerClusterSeriesData||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},Scatter.prototype.hideClusteredData=function(){var t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},i=oldPointsStateId.map(function(t){return(e[t].point||{}).id||""});(t||[]).forEach(function(t){t&&-1!==i.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},Scatter.prototype.generatePoints=function(){var t,e,i,a,r,o,s,n,l,d,p,u,h,c,f,m,g=this,x=g.chart,y=g.xAxis,S=g.yAxis,C=g.options.cluster,I=g.getRealExtremes(),b=[],A=[],P=[];if(C&&C.enabled&&g.xData&&g.yData&&!x.polar){for(p=C.layoutAlgorithm.type,(c=C.layoutAlgorithm).processedGridSize=relativeLength(c.gridSize||clusterDefaultOptions.layoutAlgorithm.gridSize,x.plotWidth),c.processedDistance=relativeLength(c.distance||clusterDefaultOptions.layoutAlgorithm.distance,x.plotWidth),a=c.kmeansThreshold||clusterDefaultOptions.layoutAlgorithm.kmeansThreshold,r=Math.abs(y.toValue(c.processedGridSize/2)-y.toValue(0)),o=Math.abs(S.toValue(c.processedGridSize/2)-S.toValue(0)),m=0;m<g.xData.length;m++)g.dataMaxX||(defined(n)&&defined(s)&&defined(d)&&defined(l)?isNumber(g.yData[m])&&isNumber(d)&&isNumber(l)&&(n=Math.max(g.xData[m],n),s=Math.min(g.xData[m],s),d=Math.max(g.yData[m]||d,d),l=Math.min(g.yData[m]||l,l)):(n=s=g.xData[m],d=l=g.yData[m])),g.xData[m]>=I.minX-r&&g.xData[m]<=I.maxX+r&&(g.yData[m]||I.minY)>=I.minY-o&&(g.yData[m]||I.maxY)<=I.maxY+o&&(b.push(g.xData[m]),A.push(g.yData[m]),P.push(m));defined(n)&&defined(s)&&isNumber(d)&&isNumber(l)&&(g.dataMaxX=n,g.dataMinX=s,g.dataMaxY=d,g.dataMinY=l),u=(h=(isFunction(p)?p:g.markerClusterAlgorithms?p&&g.markerClusterAlgorithms[p]?g.markerClusterAlgorithms[p]:b.length<a?g.markerClusterAlgorithms.kmeans:g.markerClusterAlgorithms.grid:function(){return!1}).call(this,b,A,P,c))?g.getClusteredData(h,C):h,C.animation&&g.markerClusterInfo&&g.markerClusterInfo.pointsState&&g.markerClusterInfo.pointsState.oldState?(destroyOldPoints(g.markerClusterInfo.pointsState.oldState),t=g.markerClusterInfo.pointsState.newState):t={},e=g.xData.length,i=g.markerClusterInfo,u&&(g.processedXData=u.groupedXData,g.processedYData=u.groupedYData,g.hasGroupedData=!0,g.markerClusterInfo=u,g.groupMap=u.groupMap),baseGeneratePoints.apply(this),u&&g.markerClusterInfo&&((g.markerClusterInfo.clusters||[]).forEach(function(t){(f=g.points[t.index]).isCluster=!0,f.clusteredData=t.data,f.clusterPointsAmount=t.data.length,t.point=f,addEvent(f,"click",g.onDrillToCluster)}),(g.markerClusterInfo.noise||[]).forEach(function(t){t.point=g.points[t.index]}),C.animation&&g.markerClusterInfo&&(g.markerClusterInfo.pointsState={oldState:t,newState:g.getPointsState(u,i,e)}),C.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else baseGeneratePoints.apply(this)},addEvent(Chart,"render",function(){(this.series||[]).forEach(function(t){if(t.markerClusterInfo){var e=t.options.cluster,i=((t.markerClusterInfo||{}).pointsState||{}).oldState;(e||{}).animation&&t.markerClusterInfo&&0===t.chart.pointer.pinchDown.length&&"pan"!==(t.xAxis.eventArgs||{}).trigger&&i&&Object.keys(i).length&&(t.markerClusterInfo.clusters.forEach(function(e){t.animateClusterPoint(e)}),t.markerClusterInfo.noise.forEach(function(e){t.animateClusterPoint(e)}))}})}),addEvent(Point,"update",function(){if(this.dataGroup)return error("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),addEvent(Series,"destroy",Scatter.prototype.destroyClusteredData),addEvent(Series,"afterRender",function(){var t=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(e){e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),defined(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))})}),addEvent(Point,"drillToCluster",function(t){var e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;isFunction(e)&&e.call(this,t)}),addEvent(Axis,"setExtremes",function(){var t,e=this.chart,i=0;e.series.forEach(function(e){e.markerClusterInfo&&(t=animObject((e.options.cluster||{}).animation),i=t.duration||0)}),syncTimeout(function(){e.tooltip&&e.tooltip.destroy()},i)});
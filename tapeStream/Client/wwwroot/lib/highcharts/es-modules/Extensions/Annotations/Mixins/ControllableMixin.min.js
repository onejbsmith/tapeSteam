"use strict";import ControlPoint from"../ControlPoint.js";import MockPoint from"../MockPoint.js";import Tooltip from"../../../Core/Tooltip.js";import U from"../../../Core/Utilities.js";var isObject=U.isObject,isString=U.isString,merge=U.merge,splat=U.splat,controllableMixin={init:function(t,i,o){this.annotation=t,this.chart=t.chart,this.options=i,this.points=[],this.controlPoints=[],this.index=o,this.linkPoints(),this.addControlPoints()},attr:function(){this.graphic.attr.apply(this.graphic,arguments)},getPointsOptions:function(){var t=this.options;return t.points||t.point&&splat(t.point)},attrsFromOptions:function(t){var i,o,n=this.constructor.attrsMap,s={},r=this.chart.styledMode;for(i in t)!(o=n[i])||r&&-1!==["fill","stroke","stroke-width"].indexOf(o)||(s[o]=t[i]);return s},anchor:function(t){var i=t.series.getPlotBox(),o=t.series.chart,n=t.mock?t.toAnchor():Tooltip.prototype.getAnchor.call({chart:t.series.chart},t),s={x:n[0]+(this.options.x||0),y:n[1]+(this.options.y||0),height:n[2]||0,width:n[3]||0};return{relativePosition:s,absolutePosition:merge(s,{x:s.x+(t.mock?i.translateX:o.plotLeft),y:s.y+(t.mock?i.translateY:o.plotTop)})}},point:function(t,i){if(t&&t.series)return t;if(!i||null===i.series)if(isObject(t))i=new MockPoint(this.chart,this,t);else if(isString(t))i=this.chart.get(t)||null;else if("function"==typeof t){var o=t.call(i,this);i=o.series?o:new MockPoint(this.chart,this,t)}return i},linkPoints:function(){var t,i,o=this.getPointsOptions(),n=this.points,s=o&&o.length||0;for(t=0;t<s;t++){if(!(i=this.point(o[t],n[t])))return void(n.length=0);i.mock&&i.refresh(),n[t]=i}return n},addControlPoints:function(){var t=this.options.controlPoints;(t||[]).forEach(function(i,o){var n=merge(this.options.controlPointOptions,i);n.index||(n.index=o),t[o]=n,this.controlPoints.push(new ControlPoint(this.chart,this,n))},this)},shouldBeDrawn:function(){return Boolean(this.points.length)},render:function(t){this.controlPoints.forEach(function(t){t.render()})},redraw:function(t){this.controlPoints.forEach(function(i){i.redraw(t)})},transform:function(t,i,o,n,s){if(this.chart.inverted){var r=i;i=o,o=r}this.points.forEach(function(r,e){this.transformPoint(t,i,o,n,s,e)},this)},transformPoint:function(t,i,o,n,s,r){var e=this.points[r];e.mock||(e=this.points[r]=MockPoint.fromPoint(e)),e[t](i,o,n,s)},translate:function(t,i){this.transform("translate",null,null,t,i)},translatePoint:function(t,i,o){this.transformPoint("translate",null,null,t,i,o)},translateShape:function(t,i){var o=this.annotation.chart,n=this.annotation.userOptions,s=o.annotations.indexOf(this.annotation),r=o.options.annotations[s];this.translatePoint(t,i,0),r[this.collection][this.index].point=this.options.point,n[this.collection][this.index].point=this.options.point},rotate:function(t,i,o){this.transform("rotate",t,i,o)},scale:function(t,i,o,n){this.transform("scale",t,i,o,n)},setControlPointsVisibility:function(t){this.controlPoints.forEach(function(i){i.setVisibility(t)})},destroy:function(){this.graphic&&(this.graphic=this.graphic.destroy()),this.tracker&&(this.tracker=this.tracker.destroy()),this.controlPoints.forEach(function(t){t.destroy()}),this.chart=null,this.points=null,this.controlPoints=null,this.options=null,this.annotation&&(this.annotation=null)},update:function(t){var i=this.annotation,o=merge(!0,this.options,t),n=this.graphic.parentGroup;this.destroy(),this.constructor(i,o),this.render(n),this.redraw()}};export default controllableMixin;